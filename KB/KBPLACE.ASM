;
; kbplace - Place one keystroke in keyboard buffer.
;
; int kbplace (int where, int value, int scan);
;
; int  where    KB_HEAD if keystroke is to be placed at head of queue
;               KB_TAIL if at tail
; int  value    ASCII value of keystroke (0 if not an ASCII character)
; int  scan     Scan code of keystroke.
;
; Description	This function places one keystroke at the head or tail
;		of the BIOS type-ahead buffer if there is room for it.
;
;		KBPLACE assumes that the BIOS type-ahead buffer is at
;		the standard location of 0x40:0x1e.  It will probably
;		malfunction if such is not the case.
;
;		The BIOS keyboard buffer is arranged as a circular queue
;		of fifteen pairs of bytes (plus one pair for overhead).
;		For extended key sequences the character value is 0 and
;		the scan code is as described in the IBM Technical
;		Reference.  For ASCII characters, on the other hand, the
;		first byte of the pair is the ASCII code for the
;		character and the second is the keystroke's scan code
;		(if the key was generated by a normal scan code) or 0
;		(if the key was generated by ALT plus the numeric ASCII
;		code on the numeric keypad).  For instance,
;
;		    pressing 'A' generates character 65, scan code 30,
;
;		but
;
;		    pressing ALT + 65 generates character 65, scan code 0.
;
;		(Virtually all application programs treat those two
;		cases identically.)
;
; Returns       KB_OK   (0)     if successful
;               KB_FULL (1)     if buffer full
;               KB_PLACE(2)     if the place specified was neither the
;                               head nor the tail of the queue.
;

include begasm.mac
beginProg kbplace

    KB_HEAD equ  0
    KB_TAIL equ  1

    where   equ   word ptr [bp + stkoff + 0] ; Addresses of arguments
    value   equ   byte ptr [bp + stkoff + 2]
    scan    equ   byte ptr [bp + stkoff + 4]

    buffer_head   equ word ptr ds:1ah
    buffer_tail   equ word ptr ds:1ch
    kb_buffer     equ         1eh
    kb_buffer_end equ         3eh

    beginCode

        push    ds
        pushf                           ; Save interrupt state.

        mov     ax, 40h                 ; Segment address of BIOS data
        mov ds, ax
        assume  ds:nothing

        cli                             ; Disable interrupts.
        cmp where, KB_HEAD
        jz      at_head
        cmp where, KB_TAIL
        jz      at_tail
        mov ax, 2
        jmp short exit

at_head:mov     bx, buffer_head
        dec     bx                      ; Tentatively step head back.
        dec bx
        cmp bx, kb_buffer
        jae k5h
        mov     bx, kb_buffer_end-2     ; so wrap to end.
k5h:    cmp     bx, buffer_tail         ; Now BX has new head pointer.
        je  no_room
        mov al, value
        mov ah, scan
        mov     [bx], ax                ; Store value & scan code
        mov     buffer_head, bx         ; New head pointer.
        jmp short success

at_tail:mov     bx, buffer_tail
        mov cx, bx
        inc     cx                      ; Tentatively advance new tail.
        inc cx
        cmp cx, kb_buffer_end
        jb  k5
        mov     cx, kb_buffer           ; so wrap to beginning.
k5:     cmp     cx, buffer_head         ; Now CX has new tail.
        je  no_room
        mov al, value
        mov ah, scan
        mov     [bx], ax                ; Store value & scan code
        mov     buffer_tail, cx         ; New tail pointer.

success:
        xor     ax, ax
        jmp short exit
no_room:
        mov     ax, 1
exit:   popff                           ; Restore interrupt state.
        pop    ds

   endCode
endProg kbplace
end
